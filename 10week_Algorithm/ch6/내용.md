# 6-A 2792
1. 처음 접근 : 나누어지는 경우의 수 중 → 최소 질투값 구함 
2. 질투값을 먼저 선정 → 나눔 

n의 범위는 10억이라서 1번 처럼 접근하기가 힘듬. 
특정 조건 값을 이분 탐색으로 결정하고 나누는 방법 생각해야할 듯 

# 6-M 11053

#### 1.
#### 2. O(n^2)
배열 2개 

``` cpp
for(int i = 0; i< n; i++){
        int mx = 0; 
        for(int j = 0; j<i ; j++){
            if(arr[j] < arr[i] && mx < carr[j]){ // 이전(j) 값이 현재(i) 보다 작은 값중, 중첩횟수 (carr[j])가 가장 큰 것 찾기 
                mx = carr[j];
            }
        }
        carr[i] = mx + 1;
        mmx = max(mmx, carr[i]);
    }
```

# 6-N 14002
``` cpp
int prev_idx[1001]; // 

// 1. 현재 위치(idx) 초기화 + 이전 위치 prev_idx 저장 
for(int i = 0; i < n; i++){
        for(int j = 0; j < i; j++){
            if(a[j] < a[i] && cnt[i] < cnt[j] + 1){
                prev_idx[i] = j; // 이전 위치 저장 
                if(ret < cnt[i]){
                    idx = i;      // 현재 위치 저장 
                }
            }
        }
}


// 2. 재귀로 이전 위치로 이동 
void go(int idx){
    if(idx == -1) return; 
    go(prev_idx[idx]);
    printf("%d ", a[idx]); 
    return;
}


go(idx); // 최종 위치 전달

```