
# 8-A 2618

dp 요소를 정하는게 어렵다
### dp 정의
1. 경찰차1가 마지막에 처리하는 사건번호
2. 경찰차2가 마지막에 처리하는 사건번호
```
dp[a][b] = C

경찰차1이 사건 번호 a 처리
경찰차2가 사건 번호 b 처리 
했을 때 움직인 최소 거리 C
```

### 좌표 초기화
* a의 좌표 (0, 0)은 v[0]
* b의 좌표 (n, n)는 v[1]
* w개의 사건들 v[2] ~ v[w + 1]
``` cpp
vector<pair<int,int>> v(1004);
v[0] = {1, 1}; // a의 위치
v[1] = {n, n}; // b의 위치

// 사건 : [2, w+1]에 위치
for(int i = 2; i<= w+1 ; i++){
    cin >> a >> b;
    v[i] = {a,b};
}
```
### 재귀
next 좌표 : 다음 사건 번호 
a와 b가 다음 사건 번호 (next) 로 움직일 때 재귀적으로 동작 
사건번호가 `w+1`일 때 반환값은 0 이어야 return 되면서 값을 더해줄 수 있음.
``` cpp
int go (int aidx, int bidx){
    if(aidx == w + 1 || bidx == w + 1){
        return 0;
    }

    int& ret = dp[aidx][bidx];
    if(ret != -1) return ret;
    ret = 0;

    int next = max(aidx, bidx) + 1;
    
    int aret = go(next, bidx);

    int bret = go(aidx, next);
}
```

### 움직인 거리
최초 a와 b 의 위치는 v[0], v[1]에 위치하므로 `go(0,1)` 로 시작한다.

``` cpp
int val(int prev, int next){
    return abs(v[prev].first - v[next].first) + abs(v[prev].second - v[next].second);
}

int go(int aidx, int bidx){ 

    int& ret = dp[aidx][bidx];
    if(ret != -1) return ret;
    ret = 0;

    int next = max(aidx, bidx) + 1;

    // a로 갈 때
    int aret = go(next, bidx);
    int aval = val(aidx, next);

    // b로 갈 때
    int bret = go(aidx, next);
    int bval = val(bidx, next); 
    
    ret = min(aret + aval, bret + bval);

    return ret;
}

int main(){
    go(0,1);
}
```
### 추적
`dp[i][b] + val(a,i) < dp[a][i] + val(b,i)` 처럼 비교하는 이유는
* i == 2일 때
    1. dp[i][b] + val(a,i) : a가 움직였을 때 `dp[0][1]`의 값
    2. dp[a][i] + val(b,i) : b가 움직였을 때 `dp[0][1]`의 값

두 값중 작은 경우일 때 움직인 것이므로
* 1번 경우일 때, `a = i`로 a가 움직이고
* 2번 경우일 때, `b = i`로 b가 움직인 것이다.

``` cpp
// a, b 시작 위치
int a = 0, b = 1;

// 사건 번호
for(int i = 2; i < w+1; i++){
    
    if(dp[i][b] + val(a,i) < dp[a][i] + val(b,i)){

        // a가 i번 사건 번호로 움직임
        a = i 
    } else{

        // b가 i번 사건 번호로 움직임
        b = i;
    }
}
```

# 8-B 1315
- 퀘스트를 깨는데 순서가 있다고 잘못 생각해 재귀로 접근

평소에 `dfs`, `백트래킹` 처럼 순서대로 재귀를 넘어가는 방식만 생각하고 있는 것 같은데, 이 문제처럼 한번에 확인하는 방법도 생각할 수 있어야 할 것 같다.

## dp 정의
현재 STR, INT 값에서 깰 수 있는 최대 퀘스트

``` cpp
int dp[1004][1004] // 최대 값이 1000을 넘지 않는 
```
## 
- 현재 st, in을 가진 사람이 몇가지 퀘스트를 깰 수 있는지
를 정말로 단순히 현재 값이 조건을 만족하는 경우의 수를 구한다.
``` cpp
// 조건을 만족했으니 
if(st >= av[i].st || in >= av[i].in){
    ret ++;
}
```
이후 현재 단계에서 추가적으로 지나는 점을 체크한다.
``` cpp
if(!visited[i]){
    visited[i] = true;
    pnt += av[i].p;
    vv. push_back(i);
}
```
1. `vv.push_back(i)`
    * 현재 단계에서 `true`로 만들어 준 값들이기 때문에
      다음 단계로 넘어갈 때는 `false`로 만들어 주어야 한다.
      ``` cpp
        for(int a : vv){
            visited[a] = false;
        }
      ```
2. `pnt += av[i].p`
    * 다음 단계는 최댓값 1000을 넘지 않는 선에서 가능한 모든 경우를            
      계산해봐야한다.
      ``` cpp
        for(int i = 0; i<= pnt; i++){
            int next_str = min(1000, st + i);
            int next_int = min(1000, in + (pnt - i));
            ret = max(ret, go(next_str, next_int));
        }
      ```
      * ret에 최댓값으로 최신화하면서 원복해온다. 


# 8-C 17258 ( 버림 )
이 문제에서 건질 내용은 1번 배열을 2번 배열과 같이 유연하게 바꿔서 생각할 수 있다는 점이다.
```
// 1.
0 0 1 1 2 2 3 2 2 1 1 0

// 2.
{2,0}, {2, 1},{5, 2}, {2, 1}

```

``` cpp
int temp = cnt[1];
int count = 1;
for(int i = 2; i<= n; i++){
    if(temp != cnt[i]){
        v.push_back({_count, temp});
        _count = 0;
        temp = cnt[i];
    }
    _count ++;
}
```

# 8-F 1514

## DP
경우의 수 너무 많은 것 같다! → DP????

1. 왼쪽 위치 IDX 
2. a에 더하는 offset 
3. b에 더하는 offset  
4. c에 더하는 offset 
5. 현재 회전하는 방향 
``` cpp
int dp[104][14][14][14][4];
```

#### offset 이 맞나..?
offset이 아직도 어려운데, 다음 idx로 움직일 때  c에 0의 값을 준다.
a의 정답을 구할 때 `in[idx] + a`와 같은 방식으로 값을 주므로 offset으로 생각함


## 경우의 수 
@가 ( 1 ~ 3 )일 때 돌릴 수 있는 방법이 다음 3가지 있기 때문에 총 9가지의 방법으로 돌릴 수 있다.
1. ( + @, 0, 0 )
2. ( + @, + @, 0 )
3. ( + @, + @, + @ )

``` cpp
// 경우의 수 9가지 >> 모두 같은 depth 
for(int i = 1; i <= 3; i++){  
    // a
    ret = min(ret, 1 + go(idx, mod(a + i * _flag) , b, c, flag));

    // a b
    ret = min(ret, 1 + go(idx, mod(a + i * _flag) , mod(b + i * _flag), c, flag));

    // a b c 
    ret = min(ret , 1 + go(idx, mod(a + i * _flag) , mod(b + i * _flag), mod(c + i * _flag), flag));
}
```

## 모듈러 연산 
0 ~ 9까지 수들로 이루어져 있으므로 모든 과정에서 이 범위를 넘어가면 안된다.
``` cpp
int mod(int cur){
    return (cur < 0) ? cur + 10 : cur % 10;
}
```

## 종료 조건 
1. a가 마지막 idx까지 검사 : return 0
2. a가 정답위치에 도달 -> 다음 idx로 넘어감 
    * 시계 방향으로 돌릴 수 있음
    * 반시계 방향으로 돌릴 수 있음 
``` cpp
int go(int idx, int a, int b, int c, int flag){

    // 1. 
    if(idx == n) return 0;

    // 2. 
    if(mod(a + in[idx]) == ans[idx]){
        int f = go(idx + 1, b, c, 0, flag);
        int s = go(idx + 1. b, c, 0, flag );
    }

}
```

# 8-G 17623

## 숫자 string으로 비교
숫자의 자릿수가 너무 크면 string으로 비교를 해야한다.
* int 는 32
* long long 64 

``` cpp
bool check( string fs, string ss){

    // fs가 초기화가 되지않았다는 것이므로 무조건 ss로 교체해야한다.
    if(fs == "") return true;

    // 1. 길이가 같다면 사전순으로 ss가 더 작은 경우 
    if(fs.size() == ss.size()){
        return ss << fs;
    }

    // 2. ss의 자릿수가 더 적은경우 
    return ss.size() < fs.size(); 
}
```

# 8-j 3563

동적 배열 카운팅 : 
## 세그먼트 트리

* pos : 영화의 위치 idx
* arr : 영화가 존재하는 위치를 표시하는 배열 (가상으로 만든 배열)
* tree : arr기반으로 만든 세그먼트 트리

영화를 m번 올리는 것을 배열로 표현하기 위해 `arr[m + n + 1]`이 있다고 가정
* [1, m] : m번 올리는 것 표시하기 위한 idx
* [m+1, n] : 초기 영화 n개
``` cpp
for (int i = 1; i <= n; i++) {
    pos[i] = m + i;

    // [1, m+n]
    update(tree, 1, 1, m + n, pos[i], 1);
}
```

#### sum
구간합 sum을 이용해 `mov` 번호 영화 이전까지의 개수 찾을 수 있다.
arr 함수는 `1` 로 영화가 있다고 표현하므로
구간합 계산을 통해 1의 개수를 구하면 위에 있던 영화의 개수를 구할 수 있다.
``` cpp
// pos[mov]에 있는 영화 위에 있는 영화들의 개수를 구할 수 있음 
sum(tree, 1, 1, m + n, 1, pos[mov] - 1)
```

#### pos[mov] 위치의 영화를 위로 올릴때
* pos[mov] = 0 
* pos[mov] = k (1 <= k <= m)

arr을 이용해서 위치를 최신화시키는 것을 update를 이용해서 tree에 한번에 적용시킨다.
``` cpp
for (int k = m; k >= 1; i--) {
    // pos[mov] = 0;
    update(tree, 1, 1, m + n, pos[mov], -1);  

    // pos[mov] = k
    update(tree, 1, 1, m+n, k, 1);
}
```


##
동적 배열 counting -> `펜윅트리`

# 8-K 2042
## 펜윅 트리

펜윅트리의 update는 `tree[idx] += val`처럼 더하기만 가능하다.
`tree[idx] = val` 과 같이 대입하는 형태는 불가능
``` cpp
void update(int idx, ll val){
    while(idx <= n){
        tree[idx] += val;
        idx += (idx & -idx);
    }
}

덧셈만 가능하기 때문에 차이(diff)를 넘겨주어야 한다.
``` cpp
ll diff = c - arr[b];
arr[b] = c;
update(b,diff);

```

## 세그먼트 트리 

누적합 : 정적배열
트리 : 동적배열


# 좌표압축 18870 
입력으로 받은 좌표의 값들을 작은 범위의 정수로 압축

입력으로 받은 좌표값들을 정렬해서 작은 값부터 차례대로 번호를 매기는 것
값 번호 → 정렬된 배열에서의 `인덱스`

## 중복 제거
``` cpp
vector<int> pv;
sort(pv.begin(), pv.end());
pv.erase(unique(pv.begin(), pv.end(), pv.end());

//1000 999 1000 999 1000 999
// 999 1000
```

## 이분탐색
v[i] 를 pv에서 몇번째 위치하는지 찾아야 하므로 시간복잡도가 `O(n^2)`
이를 `O(nlogn)`으로 바꾸기 위해서 이분탐색을 사용한다.

## map 쓰는 방법
map은 key를 정렬한다.
여기서 map의 value에는 key가 몇번째 수인지 나타내는 값이다.
``` cpp
// 초기화
m.insert({p,0});

int cnt = 0;
for(auto & m : mp){
    m.second = cnt++;
}
```