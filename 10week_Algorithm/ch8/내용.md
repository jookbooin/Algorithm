# 8-j 3563

동적 배열 카운팅 : 
## 세그먼트 트리

* pos : 영화의 위치 idx
* arr : 영화가 존재하는 위치를 표시하는 배열 (가상으로 만든 배열)
* tree : arr기반으로 만든 세그먼트 트리

영화를 m번 올리는 것을 배열로 표현하기 위해 `arr[m + n + 1]`이 있다고 가정
* [1, m] : m번 올리는 것 표시하기 위한 idx
* [m+1, n] : 초기 영화 n개
``` cpp
for (int i = 1; i <= n; i++) {
    pos[i] = m + i;

    // [1, m+n]
    update(tree, 1, 1, m + n, pos[i], 1);
}
```

#### sum
구간합 sum을 이용해 `mov` 번호 영화 이전까지의 개수 찾을 수 있다.
arr 함수는 `1` 로 영화가 있다고 표현하므로
구간합 계산을 통해 1의 개수를 구하면 위에 있던 영화의 개수를 구할 수 있다.
``` cpp
// pos[mov]에 있는 영화 위에 있는 영화들의 개수를 구할 수 있음 
sum(tree, 1, 1, m + n, 1, pos[mov] - 1)
```

#### pos[mov] 위치의 영화를 위로 올릴때
* pos[mov] = 0 
* pos[mov] = k (1 <= k <= m)

arr을 이용해서 위치를 최신화시키는 것을 update를 이용해서 tree에 한번에 적용시킨다.
``` cpp
for (int k = m; k >= 1; i--) {
    // pos[mov] = 0;
    update(tree, 1, 1, m + n, pos[mov], -1);  

    // pos[mov] = k
    update(tree, 1, 1, m+n, k, 1);
}
```


##
동적 배열 counting -> `펜윅트리`

# 8-K 2042
## 펜윅 트리

펜윅트리의 update는 `tree[idx] += val`처럼 더하기만 가능하다.
`tree[idx] = val` 과 같이 대입하는 형태는 불가능
``` cpp
void update(int idx, ll val){
    while(idx <= n){
        tree[idx] += val;
        idx += (idx & -idx);
    }
}

덧셈만 가능하기 때문에 차이(diff)를 넘겨주어야 한다.
``` cpp
ll diff = c - arr[b];
arr[b] = c;
update(b,diff);

```

## 세그먼트 트리 

누적합 : 정적배열
트리 : 동적배열
