# 8-A 2618

dp 요소를 정하는게 어렵다
### dp 정의
1. 경찰차1가 마지막에 처리하는 사건번호
2. 경찰차2가 마지막에 처리하는 사건번호
```
dp[a][b] = C

경찰차1이 사건 번호 a 처리
경찰차2가 사건 번호 b 처리 
했을 때 움직인 최소 거리 C
```

### 좌표 초기화
* a의 좌표 (0, 0)은 v[0]
* b의 좌표 (n, n)는 v[1]
* w개의 사건들 v[2] ~ v[w + 1]
``` cpp
vector<pair<int,int>> v(1004);
v[0] = {1, 1}; // a의 위치
v[1] = {n, n}; // b의 위치

// 사건 : [2, w+1]에 위치
for(int i = 2; i<= w+1 ; i++){
    cin >> a >> b;
    v[i] = {a,b};
}
```
### 재귀
next 좌표 : 다음 사건 번호 
a와 b가 다음 사건 번호 (next) 로 움직일 때 재귀적으로 동작 
사건번호가 `w+1`일 때 반환값은 0 이어야 return 되면서 값을 더해줄 수 있음.
``` cpp
int go (int aidx, int bidx){
    if(aidx == w + 1 || bidx == w + 1){
        return 0;
    }

    int& ret = dp[aidx][bidx];
    if(ret != -1) return ret;
    ret = 0;

    int next = max(aidx, bidx) + 1;
    
    int aret = go(next, bidx);

    int bret = go(aidx, next);
}
```

### 움직인 거리
최초 a와 b 의 위치는 v[0], v[1]에 위치하므로 `go(0,1)` 로 시작한다.

``` cpp
int val(int prev, int next){
    return abs(v[prev].first - v[next].first) + abs(v[prev].second - v[next].second);
}

int go(int aidx, int bidx){ 

    int& ret = dp[aidx][bidx];
    if(ret != -1) return ret;
    ret = 0;

    int next = max(aidx, bidx) + 1;

    // a로 갈 때
    int aret = go(next, bidx);
    int aval = val(aidx, next);

    // b로 갈 때
    int bret = go(aidx, next);
    int bval = val(bidx, next); 
    
    ret = min(aret + aval, bret + bval);

    return ret;
}

int main(){
    go(0,1);
}
```
### 추적
`dp[i][b] + val(a,i) < dp[a][i] + val(b,i)` 처럼 비교하는 이유는
* i == 2일 때
    1. dp[i][b] + val(a,i) : a가 움직였을 때 `dp[0][1]`의 값
    2. dp[a][i] + val(b,i) : b가 움직였을 때 `dp[0][1]`의 값

두 값중 작은 경우일 때 움직인 것이므로
* 1번 경우일 때, `a = i`로 a가 움직이고
* 2번 경우일 때, `b = i`로 b가 움직인 것이다.

``` cpp
// a, b 시작 위치
int a = 0, b = 1;

// 사건 번호
for(int i = 2; i < w+1; i++){
    
    if(dp[i][b] + val(a,i) < dp[a][i] + val(b,i)){

        // a가 i번 사건 번호로 움직임
        a = i 
    } else{

        // b가 i번 사건 번호로 움직임
        b = i;
    }
}
```

# 8-B 1315
- 퀘스트를 깨는데 순서가 있다고 잘못 생각해 재귀로 접근

평소에 `dfs`, `백트래킹` 처럼 순서대로 재귀를 넘어가는 방식만 생각하고 있는 것 같은데, 이 문제처럼 한번에 확인하는 방법도 생각할 수 있어야 할 것 같다.

## dp 정의
현재 STR, INT 값에서 깰 수 있는 최대 퀘스트

``` cpp
int dp[1004][1004] // 최대 값이 1000을 넘지 않는 
```
## 
- 현재 st, in을 가진 사람이 몇가지 퀘스트를 깰 수 있는지
를 정말로 단순히 현재 값이 조건을 만족하는 경우의 수를 구한다.
``` cpp
// 조건을 만족했으니 
if(st >= av[i].st || in >= av[i].in){
    ret ++;
}
```
이후 현재 단계에서 추가적으로 지나는 점을 체크한다.
``` cpp
if(!visited[i]){
    visited[i] = true;
    pnt += av[i].p;
    vv. push_back(i);
}
```
1. `vv.push_back(i)`
    * 현재 단계에서 `true`로 만들어 준 값들이기 때문에
      다음 단계로 넘어갈 때는 `false`로 만들어 주어야 한다.
      ``` cpp
        for(int a : vv){
            visited[a] = false;
        }
      ```
2. `pnt += av[i].p`
    * 다음 단계는 최댓값 1000을 넘지 않는 선에서 가능한 모든 경우를            
      계산해봐야한다.
      ``` cpp
        for(int i = 0; i<= pnt; i++){
            int next_str = min(1000, st + i);
            int next_int = min(1000, in + (pnt - i));
            ret = max(ret, go(next_str, next_int));
        }
      ```
      * ret에 최댓값으로 최신화하면서 원복해온다. 
# 8-j 3563

동적 배열 카운팅 : 
## 세그먼트 트리

* pos : 영화의 위치 idx
* arr : 영화가 존재하는 위치를 표시하는 배열 (가상으로 만든 배열)
* tree : arr기반으로 만든 세그먼트 트리

영화를 m번 올리는 것을 배열로 표현하기 위해 `arr[m + n + 1]`이 있다고 가정
* [1, m] : m번 올리는 것 표시하기 위한 idx
* [m+1, n] : 초기 영화 n개
``` cpp
for (int i = 1; i <= n; i++) {
    pos[i] = m + i;

    // [1, m+n]
    update(tree, 1, 1, m + n, pos[i], 1);
}
```

#### sum
구간합 sum을 이용해 `mov` 번호 영화 이전까지의 개수 찾을 수 있다.
arr 함수는 `1` 로 영화가 있다고 표현하므로
구간합 계산을 통해 1의 개수를 구하면 위에 있던 영화의 개수를 구할 수 있다.
``` cpp
// pos[mov]에 있는 영화 위에 있는 영화들의 개수를 구할 수 있음 
sum(tree, 1, 1, m + n, 1, pos[mov] - 1)
```

#### pos[mov] 위치의 영화를 위로 올릴때
* pos[mov] = 0 
* pos[mov] = k (1 <= k <= m)

arr을 이용해서 위치를 최신화시키는 것을 update를 이용해서 tree에 한번에 적용시킨다.
``` cpp
for (int k = m; k >= 1; i--) {
    // pos[mov] = 0;
    update(tree, 1, 1, m + n, pos[mov], -1);  

    // pos[mov] = k
    update(tree, 1, 1, m+n, k, 1);
}
```


##
동적 배열 counting -> `펜윅트리`

# 8-K 2042
## 펜윅 트리

펜윅트리의 update는 `tree[idx] += val`처럼 더하기만 가능하다.
`tree[idx] = val` 과 같이 대입하는 형태는 불가능
``` cpp
void update(int idx, ll val){
    while(idx <= n){
        tree[idx] += val;
        idx += (idx & -idx);
    }
}

덧셈만 가능하기 때문에 차이(diff)를 넘겨주어야 한다.
``` cpp
ll diff = c - arr[b];
arr[b] = c;
update(b,diff);

```

## 세그먼트 트리 

누적합 : 정적배열
트리 : 동적배열
