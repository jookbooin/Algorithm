# 4-A 19942
## struct
* 2개 받을 때 pair
* 3개 받을 때 triple
여러가지 받을때는 구조체로 나타낼 수 있다.

``` cpp
struct A{
    int mp,mf,ms,mv,cost;
};

// 구조체 배열 
A adj[16];

// 입력 받기 
for(int i = 0; i < n; i++){
   cin >> adj[i].p >> adj[i].f >> adj[i].s >> adj[i].v >> adj[i].cost;  
}
```

## 비트로 경우 판단하기
n 개의 선택지가 있을때
n개로 만들 수 있는 모든 경우의 수는 `1<<n -1 ` 개이다.
```
1 10 11 100 101 111 ~ (1<<n -1)

```

`bit를 이용하면 n개중 몇개의 요소들로 이루어져 있는지 확인`할 수 있다.
* 2개 : 000011, 000101
* 3개 : 000111, 101010
* 4개 : 110011, 101011

vector 를 하나 생성해서 포함하는 선택지의 번호를 넣을 수 있다.

``` cpp
for(int i = 1; i<(1<<n); i++){    
    vector<int> v
    for(int j = 0; j<n ; j++){
        if(i & (1<<j)){
            v.push_back(j+1);
        }
    }
}
```

# 4-C 17471
* 영역을 구분할때 무조건 특정 영역개수 (`2,3,4`)로 나누려고 하지않아도 되었음. 나중에 조건을 통해 `결과값 = n`으로 `2가지` 영역으로 나눌 수 있었다.

* `ret = 1` 로 설정해두고 재귀할 때 더하는 방식 기억좀...

#### 1. 전체 경우의 수
``` cpp
  for(int i = 1; i< (1 << n) - 1; i++){
     
  }
```

#### 2. 2개의 영역인지 구별
인접한 영역을 구하는 법이 어려웠다.

1. `comp`란 배열에 `영역1 : 1`, 이외의 영역은 `0`으로 표시한다.
``` cpp
for(int j = 0; j < n; j++){
        if(i & (1<< j)){
            comp[j+1] = 1;
        }else{ }

     }
```

2. 영역 별로 개수를 센다

dfs 반환값 `pair, int 등등` 생각해볼 것 
``` cpp
pair<int,int> compa =dfs(cidx,1);
pair<int,int> outa = dfs(oidx,0);

pair<int,int> dfs(int here, int area){
    visited[here] = 1;
    pair<int,int> ret = {1,people[here]}; // 초기값 ,
    for(int next : graph[start]){
        if(visited[next]) continue;
        if(comp[next] != area) continue;  // area 영역에 포함되지 않을때
        pair<int,int> temp = dfs(next, area);  
        ret.first += temp.first;
        ret.second += temp.second;
    }
    return ret;
}
```

3. 2가지 영역으로 나누어질 때는 영역 개수의 합이 `n`이고, 그렇지 않으면 `n이하`이다.
``` cpp
if(compa.first + outa.first == n){
    // 
}
```

#### 3. 개수 
