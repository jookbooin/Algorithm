# 7-A 2098
val[cur][next] : cur점 → next 점으로 가는 비용
dp[cur][visited] : 현재 cur점에 있고, 지금까지 visited (방문 점들) 상태일 때의 최소 값

#### 범위 이외의 값 초기화
val이 양수의 값을 가지므로, 범위 밖의 값인 -1로 초기화
``` cpp
memset(dp, -1, sizeof(dp));
```

#### 메모제이션 
움직이는 방법의 수는 16! 까지 나올 수도 있다.
값이 너무 크므로 메모제이션 ( 상태 저장 )을 생각한다.

```
0 → 1 → 2 → 3 → 0
0 → 1 → 3 → 2 → 0  
```

#### 비트마스킹
16자리 수들을 방문처리 표시하기 위해서 비트마스킹을 사용한다.
* 00001001 : 3번, 0번 방문
* 00001011 : 3번, 1번 0번 방문
* 00011011 : 4번, 3번, 1번, 0번 방문


#### 재귀
현재 `dfs(cur, visited)` 상태에서 방문하지 않은 점으로 이동할 때
``` cpp
dfs(int cur, int visited){
    for (int next = 0; next < n; next++) {
        // 이미 방문 
        if (visited & (1 << next)) continue;

        // 지날 수 없는 점 
        if (val[cur][next] == 0) continue;

        // next 점 방문처리 
        dfs(next, (1<<next) | visited ); 

    }
}
```

최솟값을 구하는 과정은 재귀 return을 통해서 값을 더하는 과정을 통해서 dfs(0, 1)의 최솟값을 구하면 된다.

# 7-D 2240 
1. 완전 탐색 ?
2. 경우가 큰가 ? → 2^30 승 (X)
3. 메모제이션? → `상태를 저장해야 한다` (X)

## 3차원 DP...
상태를 가져야 한다는 것을 인지

1. 시간 t
2. 자두 위치 pos
3. 이동 횟수 mcnt

dp[t][pos][mcnt] 

## 재귀 방식 

#### 1. 점화식 
``` cpp
// 1. 이동 o
go(t + 1, pos^1, m-1);

// 2. 이동 x
go(t + 1, pos, m);
```
#### 2. 재귀
``` cpp
go(int t, int pos, int mcnt){
    if(t == n) return 0; // << t = n일 때 부터 t = 0 일 때까지 +1씩 해서 올라와야 한다/

    int not_move = go(t+1, pos^1, mcnt -1);
    int move = go(t+1, pos, mcnt);

    ret = max(not_move, move) + ( pos == brr[t] - 1);
}
```

