# 7-A 2098
val[cur][next] : cur점 → next 점으로 가는 비용
dp[cur][visited] : 현재 cur점에 있고, 지금까지 visited (방문 점들) 상태일 때의 최소 값

#### 범위 이외의 값 초기화
val이 양수의 값을 가지므로, 범위 밖의 값인 -1로 초기화
``` cpp
memset(dp, -1, sizeof(dp));
```

#### 메모제이션 
움직이는 방법의 수는 16! 까지 나올 수도 있다.
값이 너무 크므로 메모제이션 ( 상태 저장 )을 생각한다.

```
0 → 1 → 2 → 3 → 0
0 → 1 → 3 → 2 → 0  
```

#### 비트마스킹
16자리 수들을 방문처리 표시하기 위해서 비트마스킹을 사용한다.
* 00001001 : 3번, 0번 방문
* 00001011 : 3번, 1번 0번 방문
* 00011011 : 4번, 3번, 1번, 0번 방문


#### 재귀
현재 `dfs(cur, visited)` 상태에서 방문하지 않은 점으로 이동할 때
``` cpp
dfs(int cur, int visited){
    for (int next = 0; next < n; next++) {
        // 이미 방문 
        if (visited & (1 << next)) continue;

        // 지날 수 없는 점 
        if (val[cur][next] == 0) continue;

        // next 점 방문처리 
        dfs(next, (1<<next) | visited ); 

    }
}
```
최솟값을 구하는 과정은 재귀 return을 통해서 값을 더하는 과정을 통해서 dfs(0, 1)의 최솟값을 구하면 된다.

# 7-B 17070
dp[r][c][dir] : `dir 모양`인 r, c에 위치하는 파이프

``` cpp
// 파이프 오른쪽 : [0] 
dp[i][j+1][0] = dp[i][j][0];
dp[i + 1][j + 1][2] += dp[i][j][0];

// 파이프 아래쪽 : [1]
dp[i+1][j][1] = dp[i][j][1];
dp[i+1][j+1][2] = dp[i][j][1];

// 파이프 오른_대각쪽 : [2]
dp[i][j+1][0] = dp[i][j][2];
dp[i+1][j][1] = dp[i][j][2];
dp[i+1][j+1][2] = dp[i][j][2];
```
# 7-C 1103

## 메모제이션
``` cpp
int& ret = dp[cr][cc];
if(ret) return ret;   // << 저장된 특정 조건 확인
```

# 7-D 2240 
1. 완전 탐색 ?
2. 경우가 큰가 ? → 2^30 승 (X)
3. 메모제이션? → `상태를 저장해야 한다` (X)

## 3차원 DP...
상태를 가져야 한다는 것을 인지

1. 시간 t
2. 자두 위치 pos
3. 이동 횟수 mcnt

dp[t][pos][mcnt] 

## 재귀 방식 

#### 1. 점화식 
``` cpp
// 1. 이동 o
go(t + 1, pos^1, m-1);

// 2. 이동 x
go(t + 1, pos, m);
```
#### 2. 재귀
``` cpp
go(int t, int pos, int mcnt){
    if(t == n) return 0; // << t = n일 때 부터 t = 0 일 때까지 +1씩 해서 올라와야 한다/

    int not_move = go(t+1, pos^1, mcnt -1);
    int move = go(t+1, pos, mcnt);

    ret = max(not_move, move) + ( pos == brr[t] - 1);
}
```

# 7-E 4811

<img src="img/4811.jpg" width="500" height="300">

알약을 모두 다먹은 경우 1을 반환하도록 하여 재귀로 더한다.

```cpp
// 1. 알약 1개 먹을 때
dfs(w-1, h+1);

// 2. 알약 반개 먹을 때
dfs(w, h-1);

/**
 * 1개 짜리 알약 w개
 * 반개 짜리 알약 h개 
*/
dp[w][h] = dfs(w-1, h+1) + dfs(w, h-1);
```

# 7-F 12852
## 최적해 
부분 최적 구조 : 9 → 3 → 1 

## trace 
dp[1] = 0
dp[3] = 1
dp[9] = 2

#### 재귀 
``` cpp
void go (int cur){
    if(cur == 0) return ;
    cout << cur << '\n'

    if (cur % 3 == 0 && dp[cur / 3] == dp[cur] - 1) {
        go(n / 3);
    } else if (cur % 2 == 0 && dp[cur / 2] == dp[cur] - 1) {
        go(n / 2);
    } else {
        go(n - 1);
    }
    return ;
}
```

#### 반복
``` cpp
while (n > 1) {
    if (n % 3 == 0 && dp[n / 3] == dp[n] - 1) {
        cout << n / 3 << " ";
        n = n / 3;
    } else if (n % 2 == 0 && dp[n / 2] == dp[n] - 1) {
        cout << n / 2 << " ";
        n = n / 2;
    } else {
        cout << n - 1 << " ";
        n = n - 1;
    }
}
```

# 7-G 2294

## `n가지` 동전 `무한히` 사용 
왼쪽부터 dp 누적

``` cpp
for (int i = 0; i < n; i++) {
        cin >> input; // 코인 
        for(int i = input; i<= k; i++){
            dp[i] = min(dp[i], dp[i - input] + 1);
        }
}
```
## `n가지` 동전 `1개씩` 사용
오른쪽부터 dp 누적 
``` cpp
for (int i = 0; i < n; i++) {
        cin >> input; // 코인 
        for(int i = k; i >= temp ; i--){
            dp[i] = min(dp[i], dp[i - input] + 1);
        }
}

// 1일 때
1 INF INF INF INF

// 2일 때
1 1 2 INF INF

// 5일 때
1 1 2 INF 1
```

