# 세그먼트 트리
#### 구간을 저장하기 위한 트리
세그먼트 트리는 `구간합을 저장하기 위한 트리`이다.

매번 구간합을 계산하는 경우의 시간복잡도는 
1. 특정 구간에 대한 합 : O(N)
2. 특정 값 수정 : O(1)

세그먼트 트리를 사용하게 되면 `O(logN)`의 시간으로 해결할 수 있다.


A = [1, 2, 3, 4, 5] 일 때 
![alt text](img/segment.png)

크기가 N인 배열이 존재할 때
1. 트리의 높이 = ceil(log2(N))
2. 세그먼트 트리의 크기 = (1 << (트리의 높이 + 1) )

## 구간 합
1. 현재 우리가 탐색하는 범위가, 우리가 찾고자 하는 구간과 완전히 겹쳐지지 않는 경우.
2. 현재 우리가 탐색하는 범위가, 우리가 찾고자 하는 구간에 완전히 속해있는 경우.
3.  1, 2번 경우를 제외한 나머지 경우. 즉, 일부만 걸쳐있는 경우.

``` cpp

// start, end : 해당 노드가 포함하고 있는 범위
// left, right : 우리가 구하고자 하는 범위 

int sum(int cur_node, int start, int end, int left, int right){
    
    // 1. 범위가 완전히 일치하지 않는 경우  
    if(left > end || right < start) return 0; 

    // 2. 탐색 범위가 완전히 속해 있다.
    if(left <= start && end <= right) return segmentTree[cur_node];

    // 3. 일부만 걸쳐있는 경우 
    int mid = (start + end) / 2;
    int left_sum = sum(cur_node*2, start, mid, left, right);
    int right_sum = sum(cur_node*2 + 1, mid+1, end, left, right);

    return left_sum + right_sum;
}
```
## 값 바꾸기
1. 바꾸고자 하는 Index값이, 현재 우리가 탐색하는 범위내에 속해있는 경우.
2. 바꾸고자 하는 Index값이, 현재 우리가 탐색하는 범위내에 속해있지 않은 경우. 

바꾸고자 하는 idx가 세그먼트 트리의 [start, end] 범위에 포함된다면 더 깊은 탐색을 통해서 값을 더해주어야 한다. 

2 → 5 로 바꾸려고 할 때 `diff = 5-2 `
``` cpp
void update_segmentTree(int cur_node, int start, int end, int idx, int diff){

    // 범위 벗어남 
    if(idx < start || idx > end) return;

    segmentTree[cur_node] = segmentTree[cur_node] + diff;

    if(start != end){
        int mid = (start + end) / 2;
        update_segmentTree(cur_node*2, start, mid, idx, diff);
        update_segmentTree(cur_node*2 + 1, mid + 1, end, idx, diff);
    }
    
}
```


# 펜윅 트리
펜윅 트리는 세그먼트 트리보다 더 적은 메모리로 연산을 처리할 수 있다.
펜윅 트리는 배열의 크기 n 만큼으로만 설정한다.
펜윅 트리는 세그먼트 트리와 다르게 `누적합 (0 ~ k번 index까지의 합)`을 많이 이용한다.
* 세그먼트 트리 : `구간합`
* 펜윅 트리 : `누적합`

![alt text](img/fenwick.png)

펜윅 트리는 `1이 존재하는 최하위 비트 값`을 이용해서 연산을 진행한다.

1. 펜윅트리는 비트를 이용해서 생성한다.
2. 각 idx를 2진수로 표현했을 때, `1`이 존재하는 최하위 비트 n을 찾는다.
3. 해당 idx로부터 n칸 앞까지의 구간연산에 대한 결과값을 찾는다.

![alt text](img/fenwick_bit.png)


#### 짝수
* 2(0010) : 최하위 비트 `2`
     idx 2부터 앞으로 `2`칸까지의 구간연산     
<br>


* 4(0100) : 최하위 비트 `4`
    idx 4부터 앞으로 `4`칸까지의 구간연산
<br>

* 12(1100) : 최하위 비트 `4`
    idx 12부터 앞으로 `4`칸까지의 구간연산


