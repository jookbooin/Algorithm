* 누적합 : 정적 배열
* 트리 : `동적 배열` + 카운티 (세그먼트 트리, 펜윅 트리, 카운팅 트리)


# 세그먼트 트리
#### 구간을 저장하기 위한 트리
세그먼트 트리는 `구간합을 저장하기 위한 트리`이다.

매번 구간합을 계산하는 경우의 시간복잡도는 
1. 특정 구간에 대한 합 : O(N)
2. 특정 값 수정 : O(1)

세그먼트 트리를 사용하게 되면 `O(logN)`의 시간으로 해결할 수 있다.


A = [1, 2, 3, 4, 5] 일 때 
![alt text](img/segment.png)

크기가 N인 배열이 존재할 때
1. 트리의 높이 = `ceil(log2(N))`
2. 세그먼트 트리의 크기 = `(1 << (트리의 높이 + 1) )`

``` cpp
int height = ceil(log2(n));
int tsize = 1 << (height + 1);
```

## 구간 합
> 출처: https://eun-jeong.tistory.com/18 

* cur_node : 노드 번호
* start, end : 해당 노드가 담당하는 범위
* left, right : 합 구해야하는 구간

* `[left,right]`와 `[start,end]`가 겹치지 않는 경우 : 교집합이 공집합인 경우
* `[left,right]`가 `[start,end]`를 완전히 포함하는 경우 : 교집합이 [start, end]인 경우
* `[start,end]`가 `[left,right]`를 완전히 포함하는 경우 : 교집합이 [left, right]인 경우
* `[left,right]`와 `[start,end]`가 겹쳐져 있는 경우 (1, 2, 3 제외한 나머지 경우)

``` cpp

int sum(int cur_node, int start, int end, int left, int right){
    
    // 1. 범위 겹치지 않는 경우 (탐색 x)
    if(left > end || right < start) return 0; 

    /**
     * 2. cur_node가 담당하는 [start,end] 범위가
     *    합을 구해야하는 범위인 [left, right] 범위에 포함되는 경우
     * 
     * [start, end]가 [left, right] 범위에 포함되기 때문에 바로 반환
     * */ 
    if(left <= start && end <= right) return segmentTree[cur_node];

    // 3. 왼쪽 or 오른쪽 자식을 루트로 하는 트리에서 다시 탐색 
    int mid = (start + end) / 2;
    int left_sum = sum(cur_node*2, start, mid, left, right);
    int right_sum = sum(cur_node*2 + 1, mid+1, end, left, right);

    return left_sum + right_sum;
}
```
#### 시간 복잡도 : `O(logN)`


## 값 바꾸기
1. `[start, end]`에 idx가 포함되는 경우
2. `[start, end]`에 idx가 포함되지 않는 경우

idx번째 수를 val로 변경한다면 
* diff = val - arr[idx]

> 왜냐하면, 세그먼트 트리는 `구간에 따른 연산 결과를 저장해놓은 트리`이기 때문에, 특정 idx의 값이 바뀌게 되면 그 값이 영향을 미치는 상위 노드들의 값도 바뀌어야 하기 때문이다.

``` cpp
void update_segmentTree(int cur_node, int start, int end, int idx, int diff){
    // 범위 벗어남 
    if(idx < start || idx > end) return;

    // idx에 영향을 받은 노드들 
    segmentTree[cur_node] = segmentTree[cur_node] + diff;

    // 리프 노드가 아닌 경우 자식 노드들도 변경해주어야 함
    if(start != end){
        int mid = (start + end) / 2;
        update_segmentTree(cur_node*2, start, mid, idx, diff);
        update_segmentTree(cur_node*2 + 1, mid + 1, end, idx, diff);
    }
    
}
```


# 펜윅 트리
펜윅 트리는 세그먼트 트리보다 더 적은 메모리로 연산을 처리할 수 있다.
펜윅 트리는 배열의 크기 n 만큼으로만 설정한다.
펜윅 트리는 세그먼트 트리와 다르게 `누적합 (0 ~ k번 index까지의 합)`을 많이 이용한다.

* 세그먼트 트리 : `구간합`
* 펜윅 트리 : `누적합`

![alt text](img/fenwick.png)

펜윅 트리는 `1이 존재하는 최하위 비트 값`을 이용해서 연산을 진행한다.

1. 펜윅트리는 `비트`를 이용해서 생성한다.
2. 각 idx를 2진수로 표현했을 때, `1`이 존재하는 최하위 비트 n을 찾는다.
3. 해당 idx로부터 `n칸 앞`까지의 구간연산에 대한 결과값을 찾는다.

![alt text](img/fenwick_bit.png)

## (Idx & -Idx)
최하위에 있는 1인 비트 위치

## tree[i]

L[i] : 마지막 1 위치
* L[1] : 1 (0001)
* L[4] : 4 (1000)
* L[10] : 2 (1010)

n개의 수를 arr[1] ~ arr[n] 이라고 할 때
tree[i] 는 arr[i] 부터 앞으로 L[i]개의 합이 저장되어 있다.
* tree[12] = arr[12]로부터 앞으로 L[12]만큼 앞에 저장되어 있다.
    = arr[9] + arr[10] + arr[11] + arr[12]
         

### Sum
![alt text](img/13.png)
tree를 이용해 arr[1] + ... + arr[13]을 구하는 방법
13 = 1101(2)
arr[1] + ... + arr[13] = tree[1101] + tree[1100] + tree[1000]
``` cpp
int sum (int idx){
    int ret = 0;
    while(idx > 0){
        ret += tree[idx];
        idx -= (idx & -idx);  
    }
}
```

## Update
![alt text](img/update.png)
``` cpp
void update(int idx, int diff){
    while(idx <= n>){
        tree[num] += diff;
        i += (idx & -idx);
    }
}
```