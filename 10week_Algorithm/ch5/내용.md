# 그리디는 sort + pq

# 5-A 2109

## 1. 구조체 정렬 
구조체를 pq에 넣을때 `operator<`을 구현한다.
priority_queue는 max_heap이 기본
operator< 이 `return true` 되는 조건일 때 위로 오게 된다.

Ob 객체
1. d는 오름차순
2. p는 내림차순

``` cpp
struct Ob{
    int d;
    int p;

    Ob(int _d, int _p): d(_d), p(_p){}

    bool operator<(const Ob& ob) const{
        if(d != ob.d){
            return d > ob.d;   // 나중에 들어온 d 값이 작을 때 위로 
        }else{
            return p < ob.p;  // 나중에 들어온 p값이 더 클 때?
        }
    }
};

priority_queue<Ob> pq;
pq.push(Ob(d,p)); // push할 때는 생성자로 넣는다.

// 1 20
// 1 2
// 2 100
// 2 8
// 3 10
// 10 50
// 20 5
```
#### [문제해설]
```cpp
for(int i = 0; i< n; i++){ 
    pq.push(v[i].second);       // 현재 날짜에서 가능한 강의

    if(pq.size() > v[i].first){ // v[i].first(일) 까지 하루에 1개씩
        pq.pop();               // 가장 pay가 큰 v[i].first (개)
    }
}
```

# 5-B 9935

## 시간복잡도 줄이는 방법 ( 입력하면서 + @ 과정 진행)
* 입력
* 특정 조건 만족시 삭제

입력을 하면서 삭제를 하기 때문에 `O(N)`의 시간복잡도가 나온다...
```cpp 
for (char in : a) { 
        st.push(in);

        if (st.size() >= sz && st.top() == b[sz - 1]) {
            string temp = "";
            for (int i = 0; i < sz; i++) {
                temp += st.top();
                st.pop();
            }

            reverse(temp.begin(), temp.end());

            if (temp != b) {
                for (auto a : temp) st.push(a);
            }
        }
    }

```
